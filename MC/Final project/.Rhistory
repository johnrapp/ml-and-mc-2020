overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00005)
Z <- measures %*% weights
print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
likelihood(states[[order(ls, decreasing = 1)[1]]])
likelihood(states[[order(ls, decreasing = 1)[2]]])
likelihood(states[[order(ls, decreasing = 1)[3]]])
render_states(states, order(ls, decreasing = 1)[c(seq(1,5))], "best")
likelihood(states[[order(ls, decreasing = 1)[2]]])
likelihood(states[[order(ls, decreasing = 1)[3]]])
likelihood <- function(state) {
state_mask <- array(0, dim=c(h, w))
outside <- 0
overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00001)
Z <- measures %*% weights
# print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
ls <- c()
ps <- c()
for (s in states) {
ls <- c(ls, likelihood(s))
ps <- c(ps, prior(s))
}
plot(ls, col="black", type="l", ylim=c(0,quantile(c(ls, ps), 0.8)),)
lines(ps, col="red")
render_states <- function(states, indices, title) {
for (s in states[indices]) {
render_state(s, title)
}
}
render_states(states, seq(1,4), "first")
render_states(states, length(states)-seq(1,5)-1, "last")
render_states(states, order(ls, decreasing = 1)[c(seq(1,5))], "best")
render_states(states, order(ls, decreasing = 1)[c(length(states)-seq(1,5)-1)], "worst")
render_states(states, sample(1:length(states), 5), "random")
likelihood <- function(state) {
state_mask <- array(0, dim=c(h, w))
outside <- 0
overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00001)
Z <- measures %*% weights
# print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
pi_ratio <- function(state_1, state_2) {
likelihood(state_1) /  likelihood(state_2)
}
x_sd <- w*.01
y_sd <- h*.01
propose <- function(state) {
i <- sample(1:state$k, 1)
p <- state$points[[i]]
if (runif(1) < 0.5) {
state$points[[i]]$x <- clamp(rnorm(1, mean = p$x, sd=x_sd), 0, w)
state$points[[i]]$y <- clamp(rnorm(1, mean = p$y, sd=y_sd), 0, h)
} else {
state$points[[i]]$w <- rnorm(1, mean = w_model(p$y), sd = w_sd)
state$points[[i]]$h <- rnorm(1, mean = h_model(p$y), sd = h_sd)
}
return (state)
}
prior <- function(x) {
prob <- 1
for (p in x$points) {
prob <- prob * dnorm(p$w, mean = w_model(p$y), sd = w_sd) * dnorm(p$h, mean = h_model(p$y), sd = h_sd)
}
prob
}
proposal_prob <- function(x) {
prior(x)
# prob <- 1
# # for (p in x$points) {
# #   prob <- prob * dmvnorm(c(p$x, p$y), mean, sigma) * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# # }
# for (p in x$points) {
#   prob <- prob * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# }
# prob
1
}
proposal_prob_ratio <- function(x, y) {
proposal_prob(x) / proposal_prob(y)
}
states <- metropolis_hastings(
propose,
proposal_prob_ratio,
pi_ratio,
2000,
initial_state
)
ls <- c()
ps <- c()
for (s in states) {
ls <- c(ls, likelihood(s))
ps <- c(ps, prior(s))
}
plot(ls, col="black", type="l", ylim=c(0,quantile(c(ls, ps), 0.8)),)
lines(ps, col="red")
render_states <- function(states, indices, title) {
for (s in states[indices]) {
render_state(s, title)
}
}
render_states(states, seq(1,4), "first")
render_states(states, length(states)-seq(1,5)-1, "last")
render_states(states, order(ls, decreasing = 1)[c(seq(1,10))], "best")
render_states(states, order(ls, decreasing = 1)[c(length(states)-seq(1,5)-1)], "worst")
render_states(states, sample(1:length(states), 5), "random")
# current_frame_nr <- 2000 # många personer spridda
# current_frame_nr <- 3000 # många personer klumpade
# current_frame_nr <- 5000 # 4 personer spridda
# current_frame_nr <- 4000 # många personer långt borta klumpade
# current_frame_nr <- 200 # många personer spridda
# current_frame_nr <- 2500 # en nära, nåra borta
# current_frame_nr <- 800 # en nära, nåra borta
# current_frame_nr <- 4500 # tre personer, två ihop, en ensam nära
# current_frame_nr <- 20 # två nära ihop, två borta ihop
# current_frame_nr <- 3100 # många ihop
# current_frame_nr <- 5600 # tre nära
# current_frame_nr <- 5950 # två nära en vid väggen
current_frame_nr <- 5750; current_k <- 4#; current_k <- 5 # fem utspridda
# current_frame_nr <- 5964-47+2; current_k <- 3 # två spridda, en vid väggen
current_frame <- readJPEG(image_files[current_frame_nr], native=FALSE)
plot_image(current_frame)
points <- data.frame()
for (x in 1:w) {
for (y in 1:h) {
if (foreground[y, x] == 1) {
points <- rbind(points, list(x=x,y=y))
}
}
}
plot(points$x, h-points$y)
clusters <- kmeans(points, current_k)
points(clusters$centers[,1], h-clusters$centers[,2], col="green")
for (k in 1:current_k) {
xc <- clusters$centers[k, 1]
yc <- clusters$centers[k, 2]
ws <- rnorm(50, mean = w_model(yc), sd = w_sd)
hs <- rnorm(50, mean = h_model(yc), sd = h_sd)
rect(
xc-ws/2,
h-(yc-hs/2),
xc+ws/2,
h-(yc+hs/2),
col = rgb(1,0,1,0.01)
)
}
points <- list()
for (k in 1:current_k) {
xc <- clusters$centers[k, 1]
yc <- clusters$centers[k, 2]
ww <- rnorm(1, mean = w_model(yc), sd = w_sd)
hh <- rnorm(1, mean = h_model(yc), sd = h_sd)
points[[k]] <- list(x=xc,y=yc,w=ww,h=hh)
}
initial_state <- list(
k = current_k,
points = points
)
render_state <- function(state, title=NULL) {
plot_image(from_grayscale(foreground), title)
for (point in state$points) {
rect((point$x - point$w/2) / w, 1-(point$y - point$h/2) / h, (point$x + point$w/2)/w, 1-(point$y + point$h/2)/h, col = rgb(1,0,0,0.5))
}
}
render_state(initial_state)
points_unif <- list()
for (k in 1:current_k) {
xc <- runif(1, 0, w)
yc <- runif(1, 0, h)
ww <- rnorm(1, mean = w_model(yc), sd = w_sd)
hh <- rnorm(1, mean = h_model(yc), sd = h_sd)
points_unif[[k]] <- list(x=xc,y=yc,w=ww,h=hh)
}
initial_state_unif <- list(
k = current_k,
points = points_unif
)
render_state(initial_state_unif)
likelihood <- function(state) {
state_mask <- array(0, dim=c(h, w))
outside <- 0
overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00001)
Z <- measures %*% weights
# print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
pi_ratio <- function(state_1, state_2) {
likelihood(state_1) /  likelihood(state_2)
}
x_sd <- w*.01
y_sd <- h*.01
propose <- function(state) {
i <- sample(1:state$k, 1)
p <- state$points[[i]]
if (runif(1) < 0.5) {
state$points[[i]]$x <- clamp(rnorm(1, mean = p$x, sd=x_sd), 0, w)
state$points[[i]]$y <- clamp(rnorm(1, mean = p$y, sd=y_sd), 0, h)
} else {
state$points[[i]]$w <- rnorm(1, mean = w_model(p$y), sd = w_sd)
state$points[[i]]$h <- rnorm(1, mean = h_model(p$y), sd = h_sd)
}
return (state)
}
prior <- function(x) {
prob <- 1
for (p in x$points) {
prob <- prob * dnorm(p$w, mean = w_model(p$y), sd = w_sd) * dnorm(p$h, mean = h_model(p$y), sd = h_sd)
}
prob
}
proposal_prob <- function(x) {
prior(x)
# prob <- 1
# # for (p in x$points) {
# #   prob <- prob * dmvnorm(c(p$x, p$y), mean, sigma) * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# # }
# for (p in x$points) {
#   prob <- prob * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# }
# prob
1
}
proposal_prob_ratio <- function(x, y) {
proposal_prob(x) / proposal_prob(y)
}
states <- metropolis_hastings(
propose,
proposal_prob_ratio,
pi_ratio,
2000,
initial_state
)
ls <- c()
ps <- c()
for (s in states) {
ls <- c(ls, likelihood(s))
ps <- c(ps, prior(s))
}
plot(ls, col="black", type="l", ylim=c(0,quantile(c(ls, ps), 0.8)),)
lines(ps, col="red")
render_states <- function(states, indices, title) {
for (s in states[indices]) {
render_state(s, title)
}
}
render_states(states, seq(1,4), "first")
render_states(states, length(states)-seq(1,5)-1, "last")
render_states(states, order(ls, decreasing = 1)[c(seq(1,10))], "best")
render_states(states, order(ls, decreasing = 1)[c(length(states)-seq(1,5)-1)], "worst")
render_states(states, sample(1:length(states), 5), "random")
likelihood <- function(state) {
state_mask <- array(0, dim=c(h, w))
outside <- 0
overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00001)
Z <- measures %*% weights
# print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
pi_ratio <- function(state_1, state_2) {
likelihood(state_1) /  likelihood(state_2)
}
x_sd <- w*.01
y_sd <- h*.01
propose <- function(state) {
i <- sample(1:state$k, 1)
p <- state$points[[i]]
if (runif(1) < 0.5) {
state$points[[i]]$x <- clamp(rnorm(1, mean = p$x, sd=x_sd), 0, w)
state$points[[i]]$y <- clamp(rnorm(1, mean = p$y, sd=y_sd), 0, h)
} else {
state$points[[i]]$w <- rnorm(1, mean = w_model(p$y), sd = w_sd)
state$points[[i]]$h <- rnorm(1, mean = h_model(p$y), sd = h_sd)
}
return (state)
}
prior <- function(x) {
prob <- 1
for (p in x$points) {
prob <- prob * dnorm(p$w, mean = w_model(p$y), sd = w_sd) * dnorm(p$h, mean = h_model(p$y), sd = h_sd)
}
prob
}
proposal_prob <- function(x) {
prior(x)
# prob <- 1
# # for (p in x$points) {
# #   prob <- prob * dmvnorm(c(p$x, p$y), mean, sigma) * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# # }
# for (p in x$points) {
#   prob <- prob * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# }
# prob
1
}
proposal_prob_ratio <- function(x, y) {
proposal_prob(x) / proposal_prob(y)
}
states <- metropolis_hastings(
propose,
proposal_prob_ratio,
pi_ratio,
10000,
initial_state
)
ls <- c()
ps <- c()
for (s in states) {
ls <- c(ls, likelihood(s))
ps <- c(ps, prior(s))
}
plot(ls, col="black", type="l", ylim=c(0,quantile(c(ls, ps), 0.8)),)
lines(ps, col="red")
render_states <- function(states, indices, title) {
for (s in states[indices]) {
render_state(s, title)
}
}
render_states(states, seq(1,4), "first")
render_states(states, length(states)-seq(1,5)-1, "last")
render_states(states, order(ls, decreasing = 1)[c(seq(1,10))], "best")
render_states(states, order(ls, decreasing = 1)[c(length(states)-seq(1,5)-1)], "worst")
render_states(states, sample(1:length(states), 5), "random")
likelihood <- function(state) {
state_mask <- array(0, dim=c(h, w))
outside <- 0
overlap <- 0
for (i in 1:state$k) {
point <- state$points[[i]]
for (x in round(point$x - point$w/2):round(point$x + point$w/2)) {
for (y in round(point$y - point$h/2):round(point$y + point$h/2)) {
if (y >= 1 && y <= h && x >= 1 && x <= w) {
if (state_mask[y, x] == 0) {
state_mask[y, x] = 1
} else {
overlap <- overlap + 1
}
} else {
outside <- outside + 1
}
}
}
}
N10 <- sum(state_mask == 1 & foreground == 0)
N01 <- sum(state_mask == 0 & foreground == 1)
measures <- c(N10, N01, outside, overlap)
# weights <- c(0.0001, 0.0001, 0.0001, 0.00005)
weights <- c(0.0001, 0.001, 0.0001, 0.00001)
Z <- measures %*% weights
# print(c(measures, exp(-Z), prior(state)))
return (exp(-Z) * prior(state))
}
pi_ratio <- function(state_1, state_2) {
likelihood(state_1) /  likelihood(state_2)
}
x_sd <- w*.01
y_sd <- h*.01
propose <- function(state) {
i <- sample(1:state$k, 1)
p <- state$points[[i]]
if (runif(1) < 0.5) {
state$points[[i]]$x <- clamp(rnorm(1, mean = p$x, sd=x_sd), 0, w)
state$points[[i]]$y <- clamp(rnorm(1, mean = p$y, sd=y_sd), 0, h)
} else {
state$points[[i]]$w <- rnorm(1, mean = w_model(p$y), sd = w_sd)
state$points[[i]]$h <- rnorm(1, mean = h_model(p$y), sd = h_sd)
}
return (state)
}
prior <- function(x) {
prob <- 1
for (p in x$points) {
prob <- prob * dnorm(p$w, mean = w_model(p$y), sd = w_sd) * dnorm(p$h, mean = h_model(p$y), sd = h_sd)
}
prob
}
proposal_prob <- function(x) {
prior(x)
# prob <- 1
# # for (p in x$points) {
# #   prob <- prob * dmvnorm(c(p$x, p$y), mean, sigma) * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# # }
# for (p in x$points) {
#   prob <- prob * dmvnorm(c(p$w, p$h), mean_size, sigma_size)
# }
# prob
1
}
proposal_prob_ratio <- function(x, y) {
proposal_prob(x) / proposal_prob(y)
}
states <- metropolis_hastings(
propose,
proposal_prob_ratio,
pi_ratio,
10000,
initial_state_unif
)
ls <- c()
ps <- c()
for (s in states) {
ls <- c(ls, likelihood(s))
ps <- c(ps, prior(s))
}
plot(ls, col="black", type="l", ylim=c(0,quantile(c(ls, ps), 0.8)),)
